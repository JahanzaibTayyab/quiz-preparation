# Advanced Quiz: Streaming in Agent Frameworks

## Step 1: Real-World Use Cases

1. **Live User Feedback**: Providing real-time progress and partial responses to end-users.
2. **Token-Level Analytics**: Analyzing LLM output at the token or delta event level for research or monitoring.
3. **Workflow Progress Tracking**: Updating dashboards or logs as agents, tools, or handoffs progress.
4. **Multi-Agent Collaboration**: Handling agent updates and handoffs in complex workflows.
5. **Custom Event Processing**: Integrating streaming events with external systems or custom UIs.
6. **Error Handling in Streaming**: Diagnosing and responding to issues as they occur in the stream.
7. **Performance Monitoring**: Measuring latency and throughput of streamed events.
8. **Streaming for Voice or Multimedia**: Adapting streaming logic for non-text outputs.
9. **Advanced Tool Integration**: Reacting to tool call and output events in real time.
10. **Asynchronous Orchestration**: Coordinating multiple async consumers of the event stream.

---

## Scenario-Based, Multi-Step Questions

### **Scenario 1: Live User Feedback and Token Streaming**

#### **Q1.1**

You want to display LLM-generated text to the user as soon as each token is produced. Which event type should you listen for?

A. `RunItemStreamEvent`
B. `RawResponsesStreamEvent`
C. `AgentUpdatedStreamEvent`
D. `ToolCallOutputItem`

#### **Q1.2**

In the provided example, which property of the event object contains the actual text delta?

A. `event.type`
B. `event.data.delta`
C. `event.item.output`
D. `event.new_agent.name`

#### **Q1.3**

If you want to ignore all raw token events and only update the UI when a full message is generated, which event type should you process?

A. `RawResponsesStreamEvent`
B. `RunItemStreamEvent` with `item.type == 'message_output_item'`
C. `AgentUpdatedStreamEvent`
D. `ToolCallItem`

#### **Q1.4**

What is the main benefit of streaming LLM output token-by-token to the user?

A. Reduced server load
B. Immediate feedback and improved perceived latency
C. Increased memory usage
D. More complex error handling

---

### **Scenario 2: Workflow Progress and Agent Updates**

#### **Q2.1**

You want to log when the current agent changes during a run (e.g., after a handoff). Which event type should you listen for?

A. `RawResponsesStreamEvent`
B. `AgentUpdatedStreamEvent`
C. `RunItemStreamEvent`
D. `ToolCallOutputItem`

#### **Q2.2**

What property of the `AgentUpdatedStreamEvent` gives you the new agent's name?

A. `event.type`
B. `event.new_agent.name`
C. `event.item.output`
D. `event.data.delta`

#### **Q2.3**

If you want to track when a tool is called and when its output is available, which event type and item types should you process?

A. `RunItemStreamEvent` with `item.type == 'tool_call_item'` and `item.type == 'tool_call_output_item'`
B. `RawResponsesStreamEvent` only
C. `AgentUpdatedStreamEvent` only
D. `RunItemStreamEvent` with `item.type == 'message_output_item'`

#### **Q2.4**

Why might you want to ignore `RawResponsesStreamEvent` in a production dashboard?

A. They are too high-level
B. They are too low-level and frequent for most user-facing applications
C. They contain only agent updates
D. They are required for all workflows

---

### **Scenario 3: Custom Event Processing and Integration**

#### **Q3.1**

You want to push progress updates to an external system every time a new message or tool output is generated. Which event(s) should you subscribe to?

A. Only `RawResponsesStreamEvent`
B. `RunItemStreamEvent` with relevant item types
C. Only `AgentUpdatedStreamEvent`
D. Only `ToolCallItem`

#### **Q3.2**

If you want to stream events asynchronously to multiple consumers (e.g., UI and logger), what Python feature is most appropriate?

A. Synchronous for-loop
B. Async generator and multiple async consumers
C. Blocking queue
D. Threading only

#### **Q3.3**

You want to display the number of jokes generated by the agent in the example. Which event and item type should you process?

A. `RunItemStreamEvent` with `item.type == 'tool_call_output_item'`
B. `RawResponsesStreamEvent` with `data.delta`
C. `AgentUpdatedStreamEvent`
D. `RunItemStreamEvent` with `item.type == 'message_output_item'`

#### **Q3.4**

For a voice assistant, you want to stream partial transcriptions as they are generated. Which event type is most analogous to this use case?

A. `RawResponsesStreamEvent`
B. `RunItemStreamEvent`
C. `AgentUpdatedStreamEvent`
D. `ToolCallOutputItem`

---

### **Scenario 4: Error Handling and Troubleshooting**

#### **Q4.1**

If an error occurs during streaming, what is a robust way to handle it in your async loop?

A. Ignore the error
B. Use try/except around the async for loop and handle/log the error
C. Let the error crash the application
D. Only handle errors in the LLM

#### **Q4.2**

You notice that no events are being received in your stream. What is a likely cause?

A. The agent has no tools
B. The input is empty
C. The event loop is not running or the async generator is not being consumed
D. The agent has no name

#### **Q4.3**

If you want to ensure that all event types are handled, what is a good pattern to use in your event loop?

A. Only handle known event types and ignore others
B. Use an else or default case to log or handle unexpected event types
C. Only process `RunItemStreamEvent`
D. Only process `RawResponsesStreamEvent`

#### **Q4.4**

You want to measure the time between when a tool is called and when its output is available. Which events should you track?

A. `RunItemStreamEvent` with `item.type == 'tool_call_item'` and `item.type == 'tool_call_output_item'`
B. Only `RawResponsesStreamEvent`
C. Only `AgentUpdatedStreamEvent`
D. Only `RunItemStreamEvent` with `item.type == 'message_output_item'`

---

### **Scenario 5: Advanced Streaming Patterns and Performance**

#### **Q5.1**

You want to throttle UI updates to avoid overwhelming the user with too many token events. What is a good approach?

A. Only process `RunItemStreamEvent` for full messages
B. Batch or debounce updates from `RawResponsesStreamEvent`
C. Ignore all events
D. Only process `AgentUpdatedStreamEvent`

#### **Q5.2**

For performance monitoring, you want to log the latency of each event type. What should you record?

A. Timestamps for each event as they are received
B. Only the final output
C. Only the first event
D. Only errors

#### **Q5.3**

You want to support both text and non-text (e.g., image) streaming in your application. What should your event handling logic do?

A. Check the event type and data payload, and handle each accordingly
B. Only process text events
C. Ignore all non-text events
D. Only process `AgentUpdatedStreamEvent`

#### **Q5.4**

You want to coordinate multiple async consumers (e.g., UI, logger, analytics) of the same event stream. What is a robust architectural pattern?

A. Use a pub-sub or broadcast channel for the async event stream
B. Only allow one consumer
C. Use blocking queues
D. Only use synchronous code

---

## Answer Key with Explanations

**Q1.1**  
Correct Answer: B  
Explanation: `RawResponsesStreamEvent` provides token-level (delta) events from the LLM.

**Q1.2**  
Correct Answer: B  
Explanation: The text delta is in `event.data.delta` for `RawResponsesStreamEvent`.

**Q1.3**  
Correct Answer: B  
Explanation: `RunItemStreamEvent` with `item.type == 'message_output_item'` signals a full message is ready.

**Q1.4**  
Correct Answer: B  
Explanation: Token streaming provides immediate feedback and improves perceived latency for users.

**Q2.1**  
Correct Answer: B  
Explanation: `AgentUpdatedStreamEvent` signals when the current agent changes.

**Q2.2**  
Correct Answer: B  
Explanation: The new agent's name is in `event.new_agent.name`.

**Q2.3**  
Correct Answer: A  
Explanation: `RunItemStreamEvent` with `tool_call_item` and `tool_call_output_item` types tracks tool calls and outputs.

**Q2.4**  
Correct Answer: B  
Explanation: Raw response events are too low-level and frequent for most user-facing dashboards.

**Q3.1**  
Correct Answer: B  
Explanation: `RunItemStreamEvent` with relevant item types is best for progress updates.

**Q3.2**  
Correct Answer: B  
Explanation: Async generators and multiple async consumers allow for flexible, non-blocking event handling.

**Q3.3**  
Correct Answer: A  
Explanation: The number of jokes is output by the tool, so process `tool_call_output_item` events.

**Q3.4**  
Correct Answer: A  
Explanation: Streaming partial transcriptions is analogous to processing `RawResponsesStreamEvent` for deltas.

**Q4.1**  
Correct Answer: B  
Explanation: Use try/except around the async for loop to handle errors robustly.

**Q4.2**  
Correct Answer: C  
Explanation: If the event loop is not running or the async generator is not consumed, no events are received.

**Q4.3**  
Correct Answer: B  
Explanation: Use an else/default case to log or handle unexpected event types.

**Q4.4**  
Correct Answer: A  
Explanation: Track both tool call and tool call output events to measure tool latency.

**Q5.1**  
Correct Answer: B  
Explanation: Batch or debounce token events to avoid overwhelming the UI.

**Q5.2**  
Correct Answer: A  
Explanation: Record timestamps for each event to monitor latency.

**Q5.3**  
Correct Answer: A  
Explanation: Check event type and data to support both text and non-text streaming.

**Q5.4**  
Correct Answer: A  
Explanation: Pub-sub or broadcast channels allow multiple async consumers to process the same event stream.

---

# End of Quiz
