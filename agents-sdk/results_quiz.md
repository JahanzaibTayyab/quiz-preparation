# Advanced Quiz: Understanding Agent Results and RunResult Objects

## Step 1: Real-World Use Cases

1. **Conversational AI State Management**: Maintaining context and agent state across multi-turn conversations.
2. **Audit and Compliance Logging**: Tracking all outputs, tool calls, and handoffs for regulatory or debugging purposes.
3. **Dynamic Workflow Routing**: Using the last agent and new items to determine next steps in complex workflows.
4. **Guardrail Monitoring and Analytics**: Logging and analyzing guardrail results for quality and compliance.
5. **Debugging and Model Evaluation**: Inspecting raw responses and run items for troubleshooting and model improvement.
6. **Integration with External Systems**: Passing results to downstream systems or APIs.
7. **Advanced Error Handling**: Diagnosing and responding to unexpected or malformed outputs.
8. **Multi-Agent Collaboration**: Coordinating results and state between multiple agents in a workflow.
9. **User Personalization**: Using result properties to tailor follow-up actions or responses.
10. **Performance Monitoring**: Analyzing run items and responses for latency, throughput, or bottlenecks.

---

## Scenario-Based, Multi-Step Questions

### **Scenario 1: Conversational AI State Management**

#### **Q1.1**

You are building a chatbot that must maintain context and agent state across multiple user turns. After a run, what is the best way to prepare the input for the next turn?

A. Use only the latest user message as input
B. Use `result.to_input_list()` to concatenate the original input and new items, then append the new user message
C. Use the `final_output` as the only input for the next run
D. Start a new run with an empty input list

#### **Q1.2**

If your system uses handoffs (e.g., from a triage agent to a language-specific agent), how can you ensure the correct agent is used for the next user message?

A. Always use the original agent
B. Use the `last_agent` property from the previous result
C. Use the agent with the most tool calls
D. Use the agent with the shortest instructions

#### **Q1.3**

You want to display the last message generated by the LLM to the user. Which property should you use?

A. `final_output`
B. `new_items[-1]` if it is a `MessageOutputItem`
C. `raw_responses[-1]`
D. `input_guardrail_results`

#### **Q1.4**

If the agent's output type is a Pydantic model, what type will `final_output` be?

A. Always a string
B. An instance of the agent's output type
C. Always a dictionary
D. Always a list

---

### **Scenario 2: Audit and Compliance Logging**

#### **Q2.1**

You need to log every tool call and handoff that occurred during a run for compliance. Which property provides this information?

A. `final_output`
B. `new_items`
C. `input_guardrail_results`
D. `raw_responses`

#### **Q2.2**

For a detailed audit, you want to know the raw LLM responses for each step in the run. Which property should you inspect?

A. `raw_responses`
B. `final_output`
C. `input`
D. `output_guardrail_results`

#### **Q2.3**

You want to log which agent performed each handoff. Where can you find this information?

A. In the `HandoffOutputItem` within `new_items`
B. In the `final_output`
C. In the `input` property
D. In the `output_guardrail_results`

#### **Q2.4**

If you want to store all messages generated during a run for later review, which property or combination should you use?

A. Only `final_output`
B. All `MessageOutputItem` objects in `new_items`
C. Only `raw_responses`
D. Only `input_guardrail_results`

---

### **Scenario 3: Dynamic Workflow Routing**

#### **Q3.1**

In a workflow, you want to branch logic based on whether a handoff or tool call occurred during the last run. Which property should you analyze?

A. `new_items`
B. `input`
C. `output_guardrail_results`
D. `last_agent`

#### **Q3.2**

If you want to access the output of a tool call made during the run, which type of item in `new_items` should you look for?

A. `MessageOutputItem`
B. `ToolCallOutputItem`
C. `HandoffCallItem`
D. `ReasoningItem`

#### **Q3.3**

You want to determine if the LLM performed any reasoning steps during the run. Which item type should you look for in `new_items`?

A. `ReasoningItem`
B. `ToolCallItem`
C. `HandoffOutputItem`
D. `MessageOutputItem`

#### **Q3.4**

If you want to know which agent was the source and which was the target in a handoff, where can you find this information?

A. In the `HandoffOutputItem` in `new_items`
B. In the `final_output`
C. In the `input` property
D. In the `raw_responses`

---

### **Scenario 4: Guardrail Monitoring and Analytics**

#### **Q4.1**

You want to analyze which guardrails were triggered during a run. Which properties should you inspect?

A. `input_guardrail_results` and `output_guardrail_results`
B. `final_output` and `input`
C. `raw_responses` and `last_agent`
D. `new_items` and `final_output`

#### **Q4.2**

If a guardrail result contains useful information for logging, where can you find it in the result object?

A. In the `input_guardrail_results` or `output_guardrail_results` properties
B. In the `final_output` property
C. In the `input` property
D. In the `last_agent` property

#### **Q4.3**

You want to programmatically check if any guardrail was tripped during a run. What is a robust approach?

A. Check if any result in `input_guardrail_results` or `output_guardrail_results` indicates a tripwire was triggered
B. Check if `final_output` is empty
C. Check if `raw_responses` is empty
D. Check if `last_agent` is None

#### **Q4.4**

For analytics, you want to aggregate the number of times each guardrail was triggered across many runs. Which properties should you aggregate?

A. `input_guardrail_results` and `output_guardrail_results` from each run
B. Only `final_output`
C. Only `raw_responses`
D. Only `new_items`

---

### **Scenario 5: Debugging and Model Evaluation**

#### **Q5.1**

You are debugging a run and want to see the original input provided to the agent. Which property should you use?

A. `input`
B. `final_output`
C. `new_items`
D. `raw_responses`

#### **Q5.2**

You want to check the type of the final output. What should you keep in mind about the `final_output` property?

A. It is always a string
B. It is always a Pydantic object
C. It is of type `Any` and may vary depending on the last agent and handoffs
D. It is always a dictionary

#### **Q5.3**

You want to compare the raw LLM output to the processed output. Which two properties should you compare?

A. `raw_responses` and `final_output`
B. `input` and `new_items`
C. `output_guardrail_results` and `final_output`
D. `last_agent` and `input`

#### **Q5.4**

If you want to debug why a tool call failed, which properties or items should you inspect?

A. `ToolCallOutputItem` in `new_items` and `raw_responses`
B. Only `final_output`
C. Only `input_guardrail_results`
D. Only `last_agent`

---

### **Scenario 6: Integration, Collaboration, and Advanced Use Cases**

#### **Q6.1**

You want to pass the results of an agent run to an external API for further processing. Which property is most likely to be used as the payload?

A. `final_output`
B. `raw_responses`
C. `input_guardrail_results`
D. `last_agent`

#### **Q6.2**

In a multi-agent workflow, you want to synchronize state between agents. Which two properties are most useful?

A. `to_input_list()` and `last_agent`
B. `final_output` and `raw_responses`
C. `input_guardrail_results` and `output_guardrail_results`
D. `new_items` and `input`

#### **Q6.3**

You want to personalize the next agent's behavior based on the last agent's output type. Which property should you inspect?

A. `last_agent.output_type`
B. `final_output`
C. `input`
D. `raw_responses`

#### **Q6.4**

For performance monitoring, you want to analyze the number and types of items generated during a run. Which property should you analyze?

A. `new_items`
B. `final_output`
C. `input_guardrail_results`
D. `last_agent`

---

## Answer Key with Explanations

**Q1.1**  
Correct Answer: B  
Explanation: `result.to_input_list()` concatenates the original input and new items, making it easy to maintain context and prepare for the next turn.

**Q1.2**  
Correct Answer: B  
Explanation: The `last_agent` property tells you which agent handled the last step, which is important for workflows with handoffs.

**Q1.3**  
Correct Answer: A  
Explanation: `final_output` is the last message or object generated by the LLM, suitable for display to the user.

**Q1.4**  
Correct Answer: B  
Explanation: If the agent's output type is a Pydantic model, `final_output` will be an instance of that type.

**Q2.1**  
Correct Answer: B  
Explanation: `new_items` contains all run items, including tool calls and handoffs, for compliance and audit logging.

**Q2.2**  
Correct Answer: A  
Explanation: `raw_responses` contains the raw LLM responses for each step in the run.

**Q2.3**  
Correct Answer: A  
Explanation: `HandoffOutputItem` in `new_items` contains information about the source and target agents for each handoff.

**Q2.4**  
Correct Answer: B  
Explanation: All `MessageOutputItem` objects in `new_items` represent messages generated during the run.

**Q3.1**  
Correct Answer: A  
Explanation: `new_items` lets you analyze what happened during the run, including handoffs and tool calls.

**Q3.2**  
Correct Answer: B  
Explanation: `ToolCallOutputItem` in `new_items` contains the output of tool calls.

**Q3.3**  
Correct Answer: A  
Explanation: `ReasoningItem` in `new_items` indicates reasoning steps performed by the LLM.

**Q3.4**  
Correct Answer: A  
Explanation: `HandoffOutputItem` in `new_items` contains both source and target agent information.

**Q4.1**  
Correct Answer: A  
Explanation: `input_guardrail_results` and `output_guardrail_results` show which guardrails were triggered.

**Q4.2**  
Correct Answer: A  
Explanation: Guardrail results are found in the `input_guardrail_results` or `output_guardrail_results` properties.

**Q4.3**  
Correct Answer: A  
Explanation: You can check if any result in the guardrail results indicates a tripwire was triggered.

**Q4.4**  
Correct Answer: A  
Explanation: Aggregating these properties across runs gives you analytics on guardrail triggers.

**Q5.1**  
Correct Answer: A  
Explanation: The `input` property contains the original input provided to the agent.

**Q5.2**  
Correct Answer: C  
Explanation: `final_output` is of type `Any` and may be a string or an object, depending on the last agent and handoffs.

**Q5.3**  
Correct Answer: A  
Explanation: Comparing `raw_responses` and `final_output` helps debug how the LLM output was processed.

**Q5.4**  
Correct Answer: A  
Explanation: `ToolCallOutputItem` and `raw_responses` help debug tool call failures.

**Q6.1**  
Correct Answer: A  
Explanation: `final_output` is typically used as the payload for downstream APIs.

**Q6.2**  
Correct Answer: A  
Explanation: `to_input_list()` and `last_agent` help synchronize state between agents.

**Q6.3**  
Correct Answer: A  
Explanation: `last_agent.output_type` tells you the type of output to expect and personalize behavior.

**Q6.4**  
Correct Answer: A  
Explanation: `new_items` contains all items generated, useful for performance monitoring.

---

# End of Quiz
